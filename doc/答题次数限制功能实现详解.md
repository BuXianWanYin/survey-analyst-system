# 答题次数限制功能实现详解

## 一、功能概述

系统实现了三种答题次数限制功能，用于防止用户重复提交问卷：
1. **每个IP答题次数限制** - 限制同一IP地址的提交次数
2. **每个设备答题次数限制** - 限制同一设备的提交次数
3. **每个用户答题次数限制** - 限制同一用户的提交次数

**重要说明：** 系统不支持匿名提交，所有提交操作都需要用户登录。

---

## 二、实现架构

### 2.1 数据流程

```
前端提交 → FormDataController → FormDataServiceImpl → 限制验证 → 保存数据
                ↓
         获取IP、设备ID、用户ID
                ↓
         返回提交设置信息
```

### 2.2 关键组件

1. **IpUtils** - IP地址工具类，用于获取客户端真实IP
2. **FormDataController** - 控制器，接收提交请求
3. **FormDataServiceImpl** - 服务实现类，执行限制验证和保存
4. **FormSettingService** - 表单设置服务，读取限制配置
5. **ResponseMapper** - 响应数据Mapper，查询历史提交记录

---

## 三、每个IP答题次数限制实现

### 3.1 实现原理

通过获取客户端IP地址，查询该IP在指定问卷下的历史提交次数，如果超过限制则拒绝提交。

### 3.2 实现步骤

#### 步骤1：获取客户端IP地址

**位置：** `FormDataController.saveFormData()`

```java
// 获取IP地址
String ipAddress = IpUtils.getIpAddress(request);
```

**IpUtils工具类实现：**
- 优先从 `X-Forwarded-For` 请求头获取（适用于反向代理场景）
- 其次从 `Proxy-Client-IP` 获取
- 再次从 `WL-Proxy-Client-IP` 获取
- 最后从 `X-Real-IP` 获取
- 如果都获取不到，使用 `request.getRemoteAddr()`
- 处理多个IP的情况（取第一个）
- 处理IPv6地址转换为IPv4

#### 步骤2：读取限制配置

**位置：** `FormDataServiceImpl.saveFormData()`

```java
// 获取表单设置
FormSetting formSetting = formSettingService.getBySurveyId(surveyId);
Map<String, Object> settings = formSetting.getSettings();

// 读取IP限制开关
Object ipLimitStatusObj = settings.get("ipWriteCountLimitStatus");
boolean ipLimitStatus = false;
if (ipLimitStatusObj instanceof Boolean) {
    ipLimitStatus = (Boolean) ipLimitStatusObj;
} else if (ipLimitStatusObj != null) {
    ipLimitStatus = Boolean.parseBoolean(ipLimitStatusObj.toString());
}
```

**配置存储位置：**
- 数据库表：`form_setting`
- 字段：`settings` (JSON格式)
- 配置项：
  - `ipWriteCountLimitStatus` (Boolean) - 是否启用IP限制
  - `ipWriteCountLimit` (Integer) - IP限制次数

#### 步骤3：查询历史提交次数

**位置：** `FormDataServiceImpl.saveFormData()`

```java
if (ipLimitStatus) {
    // 读取限制次数
    Object ipLimitObj = settings.get("ipWriteCountLimit");
    int ipLimit = 1; // 默认1次
    if (ipLimitObj instanceof Number) {
        ipLimit = ((Number) ipLimitObj).intValue();
    }
    
    // 查询该IP的提交次数（从Response表查询）
    LambdaQueryWrapper<Response> ipWrapper = new LambdaQueryWrapper<>();
    ipWrapper.eq(Response::getSurveyId, surveyId)      // 同一问卷
             .eq(Response::getIpAddress, ipAddress)     // 同一IP
             .eq(Response::getStatus, "COMPLETED");     // 已完成状态
    long ipCount = responseMapper.selectCount(ipWrapper);
    
    // 判断是否超过限制
    if (ipCount >= ipLimit) {
        throw new RuntimeException("该IP地址已达到答题次数限制（" + ipLimit + "次），无法继续提交");
    }
}
```

**查询逻辑说明：**
- 查询条件：
  - `survey_id` = 当前问卷ID
  - `ip_address` = 当前客户端IP
  - `status` = "COMPLETED" (只统计已完成的提交)
- 统计方式：使用 `count()` 方法统计符合条件的记录数

#### 步骤4：验证时机

验证在**保存数据之前**进行，如果超过限制会抛出异常，阻止数据保存。

---

## 四、每个设备答题次数限制实现

### 4.1 实现原理

通过前端生成并存储设备唯一标识（deviceId），后端查询该设备在指定问卷下的历史提交次数，如果超过限制则拒绝提交。

### 4.2 实现步骤

#### 步骤1：前端生成设备ID

**位置：** `survey-analyst-web/src/views/survey/fill/index.vue`

```javascript
// 生成设备ID（使用localStorage存储，用于设备限制）
let deviceId = localStorage.getItem('deviceId')
if (!deviceId) {
  deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
  localStorage.setItem('deviceId', deviceId)
}
```

**设备ID生成规则：**
- 格式：`device_时间戳_随机字符串`
- 存储：使用浏览器 `localStorage` 持久化存储
- 特点：同一浏览器/设备会生成相同的设备ID

#### 步骤2：前端传递设备ID

**位置：** `survey-analyst-web/src/api/form.js`

```javascript
submitFormData(formKey, answers, deviceId) {
  const params = {
    formKey,
    originalData: answers
  }
  if (deviceId) {
    params.deviceId = deviceId
  }
  return request.post('/form/data', params)
}
```

#### 步骤3：后端接收设备ID

**位置：** `FormDataController.saveFormData()`

```java
// 获取设备ID（从请求参数中获取）
String deviceId = (String) params.get("deviceId");
```

#### 步骤4：读取限制配置并验证

**位置：** `FormDataServiceImpl.saveFormData()`

```java
// 检查设备限制（需要设备ID）
if (deviceId != null && !deviceId.isEmpty()) {
    Object deviceLimitStatusObj = settings.get("deviceWriteCountLimitStatus");
    boolean deviceLimitStatus = false;
    if (deviceLimitStatusObj instanceof Boolean) {
        deviceLimitStatus = (Boolean) deviceLimitStatusObj;
    } else if (deviceLimitStatusObj != null) {
        deviceLimitStatus = Boolean.parseBoolean(deviceLimitStatusObj.toString());
    }
    
    if (deviceLimitStatus) {
        // 读取限制次数
        Object deviceLimitObj = settings.get("deviceWriteCountLimit");
        int deviceLimit = 1;
        if (deviceLimitObj instanceof Number) {
            deviceLimit = ((Number) deviceLimitObj).intValue();
        }
        
        // 查询该设备的提交次数（从FormData表查询）
        LambdaQueryWrapper<FormData> deviceWrapper = new LambdaQueryWrapper<>();
        deviceWrapper.eq(FormData::getFormKey, formKey);
        // 注意：当前实现是查询该formKey下的所有提交
        // 如果需要精确匹配设备ID，需要在FormData表中添加device_id字段
        long deviceCount = this.count(deviceWrapper);
        
        if (deviceCount >= deviceLimit) {
            throw new RuntimeException("该设备已达到答题次数限制（" + deviceLimit + "次），无法继续提交");
        }
    }
}
```

**当前实现说明：**
- 当前实现基于 `formKey` 统计所有提交次数
- **优化建议：** 如果需要在FormData表中精确匹配设备ID，需要：
  1. 在 `form_data` 表添加 `device_id` 字段
  2. 保存FormData时记录deviceId
  3. 查询时使用 `device_id` 字段进行精确匹配

**配置存储位置：**
- 数据库表：`form_setting`
- 配置项：
  - `deviceWriteCountLimitStatus` (Boolean) - 是否启用设备限制
  - `deviceWriteCountLimit` (Integer) - 设备限制次数

---

## 五、每个用户答题次数限制实现

### 5.1 实现原理

系统不支持匿名提交，所有提交都需要用户登录。通过获取当前登录用户的ID，查询该用户在指定问卷下的历史提交次数，如果超过限制则拒绝提交。

### 5.2 实现步骤

#### 步骤1：获取当前登录用户ID

**位置：** `FormDataController.saveFormData()`

```java
// 获取用户ID（系统不支持匿名提交，必须登录）
Long userId = null;
if (userService != null) {
    // 从SecurityContext获取当前登录用户
    com.server.surveyanalystserver.entity.User currentUser = userService.getCurrentUser();
    if (currentUser != null) {
        userId = currentUser.getId();
    } else {
        throw new RuntimeException("用户未登录，无法提交");
    }
} else {
    throw new RuntimeException("用户服务未配置，无法提交");
}
```

**用户认证流程：**
1. 前端在请求头中携带JWT Token
2. `JwtAuthenticationFilter` 拦截请求，验证Token
3. 验证通过后，将用户信息存入 `SecurityContext`
4. `UserService.getCurrentUser()` 从 `SecurityContext` 获取当前用户

#### 步骤2：读取限制配置并验证

**位置：** `FormDataServiceImpl.saveFormData()`

```java
// 检查用户限制（系统不支持匿名提交，userId必须不为null）
if (userId != null) {
    Object userLimitStatusObj = settings.get("accountWriteCountLimitStatus");
    boolean userLimitStatus = false;
    if (userLimitStatusObj instanceof Boolean) {
        userLimitStatus = (Boolean) userLimitStatusObj;
    } else if (userLimitStatusObj != null) {
        userLimitStatus = Boolean.parseBoolean(userLimitStatusObj.toString());
    }
    
    if (userLimitStatus) {
        // 读取限制次数
        Object userLimitObj = settings.get("accountWriteCountLimit");
        int userLimit = 1;
        if (userLimitObj instanceof Number) {
            userLimit = ((Number) userLimitObj).intValue();
        }
        
        // 查询该用户的提交次数（从Response表查询）
        LambdaQueryWrapper<Response> userWrapper = new LambdaQueryWrapper<>();
        userWrapper.eq(Response::getSurveyId, surveyId)      // 同一问卷
                  .eq(Response::getUserId, userId)            // 同一用户
                  .eq(Response::getStatus, "COMPLETED");      // 已完成状态
        long userCount = responseMapper.selectCount(userWrapper);
        
        if (userCount >= userLimit) {
            throw new RuntimeException("该用户已达到答题次数限制（" + userLimit + "次），无法继续提交");
        }
    }
}
```

**查询逻辑说明：**
- 查询条件：
  - `survey_id` = 当前问卷ID
  - `user_id` = 当前登录用户ID
  - `status` = "COMPLETED" (只统计已完成的提交)
- 统计方式：使用 `count()` 方法统计符合条件的记录数

**配置存储位置：**
- 数据库表：`form_setting`
- 配置项：
  - `accountWriteCountLimitStatus` (Boolean) - 是否启用用户限制
  - `accountWriteCountLimit` (Integer) - 用户限制次数

---

## 六、验证执行顺序

在 `FormDataServiceImpl.saveFormData()` 方法中，限制验证的执行顺序为：

1. **IP限制验证** - 最先执行
2. **设备限制验证** - 其次执行
3. **用户限制验证** - 最后执行
4. **保存数据** - 所有验证通过后才执行

**验证逻辑：**
- 如果任何一个限制验证失败，会立即抛出 `RuntimeException`
- 异常信息会返回给前端，前端显示错误提示
- 数据不会保存到数据库（事务回滚）

---

## 七、数据库表结构

### 7.1 form_setting 表

存储限制配置：

```sql
CREATE TABLE `form_setting` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `survey_id` BIGINT NOT NULL,
  `settings` JSON,  -- JSON格式存储所有设置
  `create_time` DATETIME,
  `update_time` DATETIME,
  PRIMARY KEY (`id`)
);
```

**settings字段JSON结构示例：**
```json
{
  "ipWriteCountLimitStatus": true,
  "ipWriteCountLimit": 1,
  "deviceWriteCountLimitStatus": true,
  "deviceWriteCountLimit": 1,
  "accountWriteCountLimitStatus": true,
  "accountWriteCountLimit": 1
}
```

### 7.2 response 表

存储提交记录，用于统计IP和用户限制：

```sql
CREATE TABLE `response` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `survey_id` BIGINT NOT NULL,
  `user_id` BIGINT,              -- 用户ID（必须，系统不支持匿名）
  `ip_address` VARCHAR(50),      -- IP地址
  `device_type` VARCHAR(20),     -- 设备类型
  `status` VARCHAR(20),          -- 状态：COMPLETED/DRAFT
  `submit_time` DATETIME,
  PRIMARY KEY (`id`),
  KEY `idx_survey_id` (`survey_id`),
  KEY `idx_user_id` (`user_id`),
  KEY `idx_ip_address` (`ip_address`)
);
```

### 7.3 form_data 表

存储表单数据，用于统计设备限制：

```sql
CREATE TABLE `form_data` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `form_key` VARCHAR(100) NOT NULL,
  `submit_request_ip` VARCHAR(50),  -- IP地址
  `original_data` JSON,             -- 原始数据
  `create_time` DATETIME,
  PRIMARY KEY (`id`),
  KEY `idx_form_key` (`form_key`)
);
```

**注意：** 当前设备限制基于 `form_key` 统计，如需精确匹配设备，建议添加 `device_id` 字段。

---

## 八、前端实现

### 8.1 设备ID生成和传递

**位置：** `survey-analyst-web/src/views/survey/fill/index.vue`

```javascript
// 生成设备ID
let deviceId = localStorage.getItem('deviceId')
if (!deviceId) {
  deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
  localStorage.setItem('deviceId', deviceId)
}

// 提交时传递设备ID
const formDataRes = await formApi.submitFormData(formKey.value, answers, deviceId)
```

### 8.2 错误处理

```javascript
try {
  const formDataRes = await formApi.submitFormData(formKey.value, answers, deviceId)
  // 处理成功
} catch (error) {
  // 如果超过限制，后端会返回错误信息
  ElMessage.error(error.response?.data?.message || error.message || '提交失败')
}
```

---

## 九、限制验证的完整流程

```
1. 用户提交问卷
   ↓
2. FormDataController接收请求
   ↓
3. 获取IP地址（IpUtils.getIpAddress）
   ↓
4. 获取设备ID（从请求参数）
   ↓
5. 获取用户ID（UserService.getCurrentUser，必须登录）
   ↓
6. FormDataServiceImpl.saveFormData()
   ↓
7. 读取表单设置（FormSettingService）
   ↓
8. 检查IP限制（如果启用）
   ├─ 查询Response表统计IP提交次数
   ├─ 如果 >= 限制次数 → 抛出异常
   └─ 如果 < 限制次数 → 继续
   ↓
9. 检查设备限制（如果启用）
   ├─ 查询FormData表统计设备提交次数
   ├─ 如果 >= 限制次数 → 抛出异常
   └─ 如果 < 限制次数 → 继续
   ↓
10. 检查用户限制（如果启用）
    ├─ 查询Response表统计用户提交次数
    ├─ 如果 >= 限制次数 → 抛出异常
    └─ 如果 < 限制次数 → 继续
    ↓
11. 所有验证通过，保存FormData
    ↓
12. 返回提交设置信息给前端
    ↓
13. 前端根据设置显示提示和跳转
```

---

## 十、关键代码位置

### 后端代码

1. **IP工具类：** `survey-analyst-server/src/main/java/com/server/surveyanalystserver/utils/IpUtils.java`
2. **控制器：** `survey-analyst-server/src/main/java/com/server/surveyanalystserver/controller/user/FormDataController.java`
3. **服务实现：** `survey-analyst-server/src/main/java/com/server/surveyanalystserver/service/impl/FormDataServiceImpl.java`
4. **响应服务：** `survey-analyst-server/src/main/java/com/server/surveyanalystserver/service/impl/ResponseServiceImpl.java` (也包含限制验证)

### 前端代码

1. **提交逻辑：** `survey-analyst-web/src/views/survey/fill/index.vue`
2. **API接口：** `survey-analyst-web/src/api/form.js`

---

## 十一、注意事项

1. **系统不支持匿名提交**：所有提交操作都需要用户登录，`userId` 必须不为null
2. **设备限制的优化**：当前设备限制基于 `formKey` 统计，如需精确匹配，建议在 `form_data` 表添加 `device_id` 字段
3. **时间范围限制**：当前实现是统计所有历史提交，如需支持时间范围（如每天、每周），需要添加时间条件
4. **事务保证**：所有验证在事务中执行，如果验证失败，数据不会保存
5. **错误信息**：限制验证失败会抛出 `RuntimeException`，异常信息会返回给前端显示

---

## 十二、优化建议

1. **设备限制精确匹配**：在 `form_data` 表添加 `device_id` 字段，保存时记录设备ID
2. **时间范围支持**：添加时间范围限制配置（如每天、每周），在查询时添加时间条件
3. **缓存优化**：对于高频查询的限制验证，可以考虑使用Redis缓存统计结果
4. **日志记录**：记录限制验证失败的日志，便于分析和监控

---

**文档生成时间：** 2024年
**最后更新：** 修复匿名提交问题后

